import math
import pygame
import random
import sys
from main import *

from obstacle import Obstacle
from powerup import PowerUp


def blit_bike_with_front_at(screen, sprite, pos_back, dir_vector, back_margin=0):
	dx, dy = dir_vector

	# Compute angle (right = 0Â°)
	rad = math.atan2(-dy, dx)
	angle_deg = math.degrees(rad)

	# Original sprite dimensions
	w = sprite.get_width()

	# pos_back is the top-left of the trail block, so offset to center of 5x5 block
	# BLOCK_SIZE is 5, so center is at +2 (accounting for 0-indexed pixels: 0,1,2,3,4 -> center at 2)
	back_center_x = pos_back[0] + 2
	back_center_y = pos_back[1] + 2

	# Vector from back to center (unrotated)
	local_center = pygame.math.Vector2((w/2 - back_margin, 0))

	# Rotate that vector
	rotated_center = local_center.rotate(-angle_deg)

	# Compute where the sprite's center should be
	center_x = back_center_x + rotated_center.x
	center_y = back_center_y + rotated_center.y

	# Rotate the sprite
	rotated_sprite = pygame.transform.rotate(sprite, angle_deg)
	bike_rect = rotated_sprite.get_rect(center=(center_x, center_y))

	# Draw the rotated sprite
	screen.blit(rotated_sprite, bike_rect)

def get_front_pos(pos_back, dir_vector, sprite_width=None, back_margin=4):
	# Compute front point automatically from sprite width.
	dx, dy = dir_vector
	mag = math.hypot(dx, dy)
	if mag == 0:
		return pos_back
	nx, ny = dx / mag, dy / mag

	# Use sprite width if provided, otherwise default to 30
	length = (sprite_width or 30) - back_margin

	front_x = pos_back[0] + nx * length
	front_y = pos_back[1] + ny * length
	return [front_x, front_y]

def reset_sprites():
	"""Reset bike positions and trails for a new round."""
	top_left = [dirs["DOWN"], [WIDTH // 4, 35]]
	top_right = [dirs["DOWN"], [3 * WIDTH // 4, 35]]
	bottom_left = [dirs["UP"], [WIDTH // 4, HEIGHT - 35]]
	bottom_right = [dirs["UP"], [3 * WIDTH // 4, HEIGHT - 35]]
	left_top = [dirs["RIGHT"], [35, HEIGHT // 4]]
	left_bottom = [dirs["RIGHT"], [35, 3 * HEIGHT // 4]]
	right_top = [dirs["LEFT"], [WIDTH - 35, HEIGHT // 4]]
	right_bottom = [dirs["LEFT"], [WIDTH - 35, 3 * HEIGHT // 4]]

	pos = [
		top_left,
		top_right,
		bottom_left,
		bottom_right,
		right_top,
		right_bottom,
		left_top,
		left_bottom
	]

	p1_start = random.choice(pos)
	pos.remove(p1_start)

	# Ensure bikes don't start in adjacent corners
	if p1_start == top_left:
		while True:
			p2_start = random.choice(pos)
			if p2_start != left_top:
				break
	elif p1_start == top_right:
		while True:
			p2_start = random.choice(pos)
			if p2_start != right_top:
				break
	elif p1_start == bottom_left:
		while True:
			p2_start = random.choice(pos)
			if p2_start != left_bottom:
				break
	elif p1_start == bottom_right:
		while True:
			p2_start = random.choice(pos)
			if p2_start != right_bottom:
				break
	elif p1_start == right_top:
		while True:
			p2_start = random.choice(pos)
			if p2_start != top_right:
				break
	elif p1_start == right_bottom:
		while True:
			p2_start = random.choice(pos)
			if p2_start != bottom_right:
				break
	elif p1_start == left_top:
		while True:
			p2_start = random.choice(pos)
			if p2_start != top_left:
				break
	elif p1_start == left_bottom:
		while True:
			p2_start = random.choice(pos)
			if p2_start != bottom_left:
				break

	# Set player 1 position and direction
	player1.dir = p1_start[0]
	player1.pos = p1_start[1]
	player1.reset_trail()
	player1.reset_status()

	# Set player 2 position and direction
	player2.dir = p2_start[0]
	player2.pos = p2_start[1]
	player2.reset_trail()
	player2.reset_status()

	global p1_wins, p2_wins, match_over, single_player, font, small_font

	font = pygame.font.Font(tr2n, 75)
	small_font = pygame.font.Font(orbitron_regular, 20)
	global p1_wins, p2_wins, match_over, single_player

	menu_running = True

	while menu_running:

		WIN.blit(background, (0, 0))
		show_message("TRON LIGHTCYCLES", "Press \"1\" for 1 Player or \"2\" for 2 Players")
		if armory.exists():
			pygame.mixer.music.load("music/armory.mp3")
			pygame.mixer.music.play(-1)
		waiting = True
		while waiting:
			for event in pygame.event.get():
				if event.type == pygame.QUIT:
					pygame.quit()
					sys.exit()
				if event.type == pygame.KEYDOWN:
					if event.key == pygame.K_1:
						single_player = True
						p1_wins = 0
						p2_wins = 0
						match_over = False
						menu_running = False
						waiting = False
						theme_menu()
					elif event.key == pygame.K_2:
						single_player = False
						p1_wins = 0
						p2_wins = 0
						match_over = False
						menu_running = False
						waiting = False
						theme_menu()
					elif event.key == pygame.K_ESCAPE:
						pygame.quit()
						sys.exit()

def theme_menu():
	global theme, BLUE, ORANGE, WHITE, font, small_font

	theme_menu_running = True

	while theme_menu_running:
		WIN.blit(background, (0, 0))
		show_message("SELECT A THEME", "Press \"1\" for \"82\", \"2\" for \"LEGACY\", or \"3\" for \"ARES\"")
		waiting = True
		while waiting:
			for event in pygame.event.get():
				if event.type == pygame.QUIT:
					pygame.quit()
					sys.exit()
				if event.type == pygame.KEYDOWN:
					if event.key == pygame.K_1:
						theme = "82"
						BLUE = (1, 1, 254)
						ORANGE = (255, 126, 0)
						WHITE = (200, 200, 200)
						theme_menu_running = False
						waiting = False
						reset_game()
					elif event.key == pygame.K_2:
						theme = "LEGACY"
						BLUE = (2, 255, 255)
						ORANGE = (254, 148, 0)
						WHITE = (255, 255, 255)
						theme_menu_running = False
						waiting = False
						reset_game()
					elif event.key == pygame.K_3:
						theme = "ARES"
						BLUE = (0, 255, 255)
						WHITE = (255, 255, 255)
						theme_menu_running = False
						waiting = False
						reset_game()
					elif event.key == pygame.K_ESCAPE:
						pygame.quit()
						sys.exit()

def draw_squircle(surface, center_x, center_y, size, color, roundness=0.7):
	"""Draw a rounded rectangle."""
	# Calculate corner radius based on roundness parameter
	# roundness controls how rounded the corners are (0 = square, 1 = very round)
	corner_radius = int(size * roundness * 0.5)

	# Calculate top-left position from center
	x = center_x - size / 2
	y = center_y - size / 2

	# Create rectangle
	rect = pygame.Rect(x, y, size, size)

	# Draw rounded rectangle outline
	pygame.draw.rect(surface, color, rect, width=1, border_radius=corner_radius)

def draw_squircle_grid(surface, squircle_size=30, spacing=40, roundness=0.7):
	"""Draw a background grid of squircles."""
	if theme == "LEGACY":
		bg_color = (0, 0, 16)
		squircle_color = TEAL
	elif theme == "ARES":
		bg_color = (20, 0, 0)
		squircle_color = DARKEST_RED

	surface.fill(bg_color)

	width = surface.get_width()
	height = surface.get_height()

	# Create a transparent layer for squircles
	squircle_layer = pygame.Surface((width, height), pygame.SRCALPHA)

	# Calculate grid dimensions
	cols = width // spacing
	rows = height // spacing

	# Center the grid
	offset_x = (width - (cols * spacing)) / 2
	offset_y = (height - (rows * spacing)) / 2

	# Draw squircles in a grid pattern
	for row in range(rows + 1):
		for col in range(cols + 1):
			center_x = offset_x + col * spacing
			center_y = offset_y + row * spacing

			draw_squircle(squircle_layer, center_x, center_y, squircle_size, squircle_color, roundness)

	# Blit the squircle layer onto the main surface
	surface.blit(squircle_layer, (0, 0))

def draw_tron_grid(surface, desired_spacing=40):
	if theme == "LEGACY" or theme == "ARES":
		draw_squircle_grid(WIN, 90, 120, .1)
	elif theme == "82":
		color = WHITE
		surface.fill((0, 0, 20))

		width = surface.get_width()
		height = surface.get_height()

		# Compute number of full cells that fit
		cols = width // desired_spacing
		rows = height // desired_spacing

		# Adjust spacing so grid fits exactly
		spacing_x = width / cols if cols > 0 else width
		spacing_y = height / rows if rows > 0 else height

		# Draw vertical lines including the final right line
		for i in range(cols + 1):
			x = int(i * spacing_x)
			pygame.draw.line(surface, color, (x, 0), (x, height), 1)
		# Ensure a final line at the very right edge
		pygame.draw.line(surface, color, (width - 1, 0), (width - 1, height), 1)

		# Draw horizontal lines including the final bottom line
		for j in range(rows + 1):
			y = int(j * spacing_y)
			pygame.draw.line(surface, color, (0, y), (width, y), 1)
		# Ensure a final line at the very bottom edge
		pygame.draw.line(surface, color, (0, height - 1), (width, height - 1), 1)

		glow = pygame.Surface(surface.get_size(), pygame.SRCALPHA)
		for i in range(3):
			alpha = 40 - i * 10
			glow_color = (color[0], color[1], color[2], alpha)
			# Vertical glow lines
			for k in range(cols + 1):
				x = int(k * spacing_x)
				pygame.draw.line(glow, glow_color, (x, 0), (x, height), 3 + i)
			pygame.draw.line(glow, glow_color, (width - 1, 0), (width - 1, height), 3 + i)
			# Horizontal glow lines
			for l in range(rows + 1):
				y = int(l * spacing_y)
				pygame.draw.line(glow, glow_color, (0, y), (width, y), 3 + i)
			pygame.draw.line(glow, glow_color, (0, height - 1), (width, height - 1), 3 + i)

		surface.blit(glow, (0, 0))

def show_message(text, subtext="", color=TEAL):
	# Render text surfaces
	title = font.render(text, True, color)
	if subtext != "":
		subtitle = small_font.render(subtext, True, (180, 180, 180))

	# Add padding around the text
	padding_x = 20
	padding_y = 15
	spacing = 10  # vertical space between title and subtitle

	# Determine box width & height based on text sizes
	if subtext != "":
		box_width = max(title.get_width(), subtitle.get_width()) + 2 * padding_x
		box_height = title.get_height() + subtitle.get_height() + 2 * padding_y + spacing
	else:
		box_width = title.get_width() + 2 * padding_x
		box_height = title.get_height() + 2 * padding_y

	# Position box centered on screen
	box_x = WIDTH // 2 - box_width // 2
	box_y = HEIGHT // 2 - box_height // 2

	# Draw black background rectangle
	pygame.draw.rect(WIN, BLACK, (box_x, box_y, box_width, box_height))

	# Draw blue outline rectangle
	pygame.draw.rect(WIN, color, (box_x, box_y, box_width, box_height), 3)

	# Draw the text centered inside the box
	title_x = WIDTH // 2 - title.get_width() // 2
	title_y = box_y + padding_y

	if subtext != "":
		subtitle_x = WIDTH // 2 - subtitle.get_width() // 2
		subtitle_y = title_y + title.get_height() + spacing

	WIN.blit(title, (title_x, title_y))
	if subtext != "":
		WIN.blit(subtitle, (subtitle_x, subtitle_y))

	pygame.display.update()

def segments_intersect(p1, p2, p3, p4):
	# Check if line segment p1->p2 intersects with line segment p3->p4
	def ccw(A, B, C):
		# Check if three points are in counter-clockwise order
		return (C[1] - A[1]) * (B[0] - A[0]) > (B[1] - A[1]) * (C[0] - A[0])

	# Two segments intersect if the endpoints of one segment are on opposite sides of the other segment
	return ccw(p1, p3, p4) != ccw(p2, p3, p4) and ccw(p1, p2, p3) != ccw(p1, p2, p4)

def check_trail_crossing(new_p1, new_p2, trail):
	# Check if a new trail segment (new_p1 -> new_p2) crosses any existing trail segments
	if len(trail) < 2:
		return False

	# Check against all consecutive segments in the trail
	for i in range(len(trail) - 1):
		trail_p1 = trail[i]
		trail_p2 = trail[i + 1]

		# Skip if checking against the immediate previous segment (would always intersect at endpoint)
		if trail_p2 == new_p1:
			continue

		if segments_intersect(new_p1, new_p2, trail_p1, trail_p2):
			return True

	return False

def check_collision(pos, trail1_set, trail2_set):
	x, y = pos
	if x < 0 or x >= WIDTH or y < 0 or y >= HEIGHT:
		return True
	if pos in trail1_set or pos in trail2_set:
		return True
	return False


def check_rect_collision_with_trails(bike_rect, trail1, trail2):
	"""Check if a bike's hitbox rectangle collides with any trail blocks.

	Args:
		bike_rect: pygame.Rect representing the bike's axis-aligned bounding box
		trail1: list of (x, y) tuples representing trail blocks
		trail2: list of (x, y) tuples representing trail blocks

	Returns:
		True if collision detected, False otherwise
	"""
	# Check all trail blocks from both trails
	for trail in [trail1, trail2]:
		for trail_pos in trail:
			# Create a rectangle for the trail block (BLOCK_SIZE x BLOCK_SIZE)
			trail_rect = pygame.Rect(trail_pos[0], trail_pos[1], BLOCK_SIZE, BLOCK_SIZE)

			# Check if the bike's bounding box intersects the trail block
			if bike_rect.colliderect(trail_rect):
				return True

	return False


def rotated_rect_intersects_rect(center_x, center_y, width, height, angle_deg, rect):
	"""Check if a rotated rectangle intersects an axis-aligned rectangle.

	Uses Separating Axis Theorem (SAT) for accurate collision detection.

	Args:
		center_x, center_y: Center of the rotated rectangle
		width, height: Dimensions of the rotated rectangle
		angle_deg: Rotation angle in degrees
		rect: pygame.Rect representing an axis-aligned rectangle

	Returns:
		True if rectangles intersect, False otherwise
	"""
	import math

	# Get corners of the rotated rectangle
	half_w = width / 2
	half_h = height / 2
	corners = [
		(-half_w, -half_h),
		(half_w, -half_h),
		(half_w, half_h),
		(-half_w, half_h)
	]

	angle_rad = math.radians(angle_deg)
	cos_a = math.cos(angle_rad)
	sin_a = math.sin(angle_rad)

	rotated_corners = []
	for x, y in corners:
		rotated_x = x * cos_a - y * sin_a + center_x
		rotated_y = x * sin_a + y * cos_a + center_y
		rotated_corners.append((rotated_x, rotated_y))

	# Get corners of the axis-aligned rectangle
	rect_corners = [
		(rect.left, rect.top),
		(rect.right, rect.top),
		(rect.right, rect.bottom),
		(rect.left, rect.bottom)
	]

	# Test separation on axes parallel to the rotated rect's edges
	axes = []
	for i in range(4):
		p1 = rotated_corners[i]
		p2 = rotated_corners[(i + 1) % 4]
		edge = (p2[0] - p1[0], p2[1] - p1[1])
		# Normal to the edge (perpendicular)
		normal = (-edge[1], edge[0])
		mag = math.hypot(normal[0], normal[1])
		if mag > 0:
			axes.append((normal[0] / mag, normal[1] / mag))

	# Test separation on axes parallel to the axis-aligned rect's edges
	axes.append((1, 0))  # X-axis
	axes.append((0, 1))  # Y-axis

	# For each axis, project both rectangles and check for overlap
	for axis in axes:
		# Project rotated rectangle corners onto axis
		rot_projections = [corner[0] * axis[0] + corner[1] * axis[1] for corner in rotated_corners]
		rot_min = min(rot_projections)
		rot_max = max(rot_projections)

		# Project axis-aligned rectangle corners onto axis
		rect_projections = [corner[0] * axis[0] + corner[1] * axis[1] for corner in rect_corners]
		rect_min = min(rect_projections)
		rect_max = max(rect_projections)

		# Check for gap (no overlap)
		if rot_max < rect_min or rect_max < rot_min:
			return False  # Separating axis found, no collision

	return True  # No separating axis found, rectangles intersect

def draw_bike_glow(bike, alpha=80):
	"""Draw a faint oval glow underneath a bike."""
	import math

	# Determine glow dimensions based on bike direction
	dx, dy = bike.dir
	if dx == 0 and dy == 0:
		# Bike not moving yet, use circular glow
		width, height = 12, 12
	elif abs(dx) > abs(dy):
		# Moving horizontally - elongate horizontally
		width, height = 27, 12
	else:
		# Moving vertically - elongate vertically
		width, height = 12, 27

	# Create a surface for the glow with per-pixel alpha
	glow_surface = pygame.Surface((width * 2, height * 2), pygame.SRCALPHA)

	# Draw multiple ellipses with decreasing alpha for a gradient effect
	for i in range(3):
		current_width = width - (i * 3)
		current_height = height - (i * 3)
		current_alpha = alpha - (i * 15)
		if current_alpha < 0:
			current_alpha = 0
		if current_width > 0 and current_height > 0:
			rect = pygame.Rect(width - current_width, height - current_height,
			                   current_width * 2, current_height * 2)
			pygame.draw.ellipse(glow_surface, (*bike.color, current_alpha), rect)

	# Calculate the center of the bike sprite
	if theme == "LEGACY" or theme == "ARES":
		sprite_width = legacy_width
		sprite_height = legacy_height
	elif theme == "82":
		sprite_width = width_82
		sprite_height = height_82


	# Get direction magnitude for centering calculation
	mag = math.hypot(dx, dy)

	# bike.pos is the top-left of the trail block, so offset to center of 5x5 block
	# BLOCK_SIZE is 5, so center is at +2 (accounting for 0-indexed pixels: 0,1,2,3,4 -> center at 2)
	back_center_x = bike.pos[0] + 2
	back_center_y = bike.pos[1] + 2

	if mag > 0:
		# Normalize direction
		nx, ny = dx / mag, dy / mag
		# Calculate center of sprite - positioned further back (40% from back)
		center_offset = sprite_width * 0.4
		center_x = back_center_x + nx * center_offset
		center_y = back_center_y + ny * center_offset
	else:
		# Bike not moving, center on position
		center_x = back_center_x
		center_y = back_center_y

	# Blit the glow centered on the bike's center
	glow_x = center_x - width
	glow_y = center_y - height
	WIN.blit(glow_surface, (glow_x, glow_y))

def get_bike_rect(bike, sprite_width, sprite_height, back_margin=4):
	"""Calculate the tight bounding rectangle for a bike sprite."""
	dx, dy = bike.dir
	mag = math.hypot(dx, dy)

	if mag == 0:
		# Bike not moving, return a small rect at position
		return pygame.Rect(bike.pos[0], bike.pos[1], sprite_width, sprite_height)

	# Normalize direction
	nx, ny = dx / mag, dy / mag

	# Calculate angle for rotation
	rad = math.atan2(-dy, dx)
	angle_deg = math.degrees(rad)

	# Bike center position (accounting for trail block offset)
	back_center_x = bike.pos[0] + 2
	back_center_y = bike.pos[1] + 2

	# Vector from back to sprite center
	local_center = pygame.math.Vector2((sprite_width/2 - back_margin, 0))
	rotated_center = local_center.rotate(-angle_deg)

	center_x = back_center_x + rotated_center.x
	center_y = back_center_y + rotated_center.y

	# Create rect centered at sprite center
	# Use slightly smaller dimensions for tighter collision (90% of sprite size)
	tight_width = sprite_width * 0.9
	tight_height = sprite_height * 0.9

	rect = pygame.Rect(0, 0, tight_width, tight_height)
	rect.center = (center_x, center_y)

	return rect

def draw_rotated_rect(surface, color, center_x, center_y, width, height, angle_deg, line_width=2):
	"""Draw a rotated rectangle using polygon drawing."""
	import math

	# Create corner points for an unrotated rectangle centered at origin
	half_w = width / 2
	half_h = height / 2
	corners = [
		(-half_w, -half_h),
		(half_w, -half_h),
		(half_w, half_h),
		(-half_w, half_h)
	]

	# Rotate each corner point
	angle_rad = math.radians(angle_deg)
	cos_a = math.cos(angle_rad)
	sin_a = math.sin(angle_rad)

	rotated_corners = []
	for x, y in corners:
		rotated_x = x * cos_a - y * sin_a
		rotated_y = x * sin_a + y * cos_a
		rotated_corners.append((center_x + rotated_x, center_y + rotated_y))

	# Draw the polygon
	pygame.draw.polygon(surface, color, rotated_corners, line_width)


def draw_sprites():
	"""Render both bikes on the screen."""
	import math

	# Draw glows in legacy mode before rendering bikes
	if theme == "LEGACY" or theme == "ARES":
		draw_bike_glow(player1)
		draw_bike_glow(player2)

	player1.render(WIN, blit_bike_with_front_at, back_margin=4)
	player2.render(WIN, blit_bike_with_front_at, back_margin=4)

def draw_scoreboard():
	p1_text = small_font.render(f"Blue: {p1_wins}", True, BLUE)
	if theme == "ARES":
		p2_text = small_font.render(f"Red: {p2_wins}", True, RED)
	else:
		p2_text = small_font.render(f"Orange: {p2_wins}", True, ORANGE)

	# Space them evenly at the top center
	total_width = p1_text.get_width() + p2_text.get_width() + 50
	start_x = WIDTH // 2 - total_width // 2

	WIN.blit(p1_text, (start_x, 10))
	WIN.blit(p2_text, (start_x + p1_text.get_width() + 50, 10))

def reset_game():
	"""Reset the game for a new round."""
	global game_over, game_time_offset, last_powerup_spawn, player1, player2

	if theme == "LEGACY":
		player1 = Bike(blue_legacy_sprite, BLUE, "Blue")
		player2 = Bike(orange_legacy_sprite, ORANGE, "Orange")
	elif theme == "ARES":
		player1 = Bike(blue_legacy_sprite, BLUE, "Blue")
		player2 = Bike(red_ares_sprite, RED, "Red")
	elif theme == "82":
		player1 = Bike(blue_82_sprite, BLUE, "Blue")
		player2 = Bike(orange_82_sprite, ORANGE, "Orange")

	reset_sprites()
	clear_powerups()
	generate_obstacles()

	game_over = False

	# Redraw background clean
	WIN.fill(BLACK)
	pygame.display.update()

	countdown()
	game_time_offset = pygame.time.get_ticks()
	last_powerup_spawn = 0

def generate_obstacles():
	"""Generate random obstacles avoiding player positions."""
	global obstacles
	obstacles = []

	NUM_OBSTACLES = random.randint(10, 15)
	MAX_ATTEMPTS = 100  # Avoid infinite loops

	while len(obstacles) < NUM_OBSTACLES:
		attempt = 0
		while attempt < MAX_ATTEMPTS:
			size = random.randint(30, 60)
			x = random.randrange(0, WIDTH - size, OBSTACLE_SIZE)
			y = random.randrange(0, HEIGHT - size, OBSTACLE_SIZE)

			# Create temp obstacle to check for collisions
			temp_obstacle = Obstacle(x, y, size)

			# Avoid spawning near players (150 pixel margin)
			if temp_obstacle.is_near_position(player1.pos, 150) or \
			   temp_obstacle.is_near_position(player2.pos, 150):
				attempt += 1
				continue

			# Check for overlap with existing obstacles
			overlap = any(temp_obstacle.overlaps_with(obs) for obs in obstacles)

			if not overlap:
				obstacles.append(temp_obstacle)
				break

			attempt += 1

		# If we exceeded attempts, just skip this obstacle
		if attempt >= MAX_ATTEMPTS:
			break

def draw_obstacles():
	"""Render all obstacles on the screen."""
	for obstacle in obstacles:
		obstacle.render(WIN, theme)

def spawn_powerup():
	"""Spawn a new random power-up not overlapping obstacles or trails."""
	global powerups
	ptype = random.choice(PowerUp.TYPES)
	size = POWERUP_SIZE

	for _ in range(30):  # try 30 times
		x = random.randrange(0, WIDTH - size, POWERUP_SIZE)
		y = random.randrange(0, HEIGHT - size, POWERUP_SIZE)

		# Avoid obstacles
		overlap = any(obs.contains_point(x, y) for obs in obstacles)

		# Avoid trails - check if powerup overlaps with any trail positions
		if not overlap:
			for trail_pos in player1.trail + player2.trail:
				tx, ty = trail_pos
				# Check if powerup rectangle overlaps with trail block
				if (x < tx + BLOCK_SIZE and x + size > tx and
				    y < ty + BLOCK_SIZE and y + size > ty):
					overlap = True
					break

		if not overlap:
			powerups.append(PowerUp(x, y, size, ptype))
			break

def draw_powerups():
	"""Render all power-ups on the screen."""
	for powerup in powerups:
		powerup.render(WIN)

def clear_powerups():
	"""Remove all power-ups from the board."""
	global powerups
	powerups.clear()

def check_powerup_collision(pos, bike, current_time):
	"""Check if a bike hits a power-up and apply effect."""
	global powerups

	for pu in powerups[:]:
		if pu.contains_point(pos[0], pos[1]):
			pu.apply_effect(bike, current_time)
			powerups.remove(pu)

def check_trail_powerup_collisions(current_time):
	"""Check if any trails cross over power-ups."""
	global powerups

	for pu in powerups[:]:
		# Check if player1's trail crosses this power-up
		for trail_pos in player1.trail:
			tx, ty = trail_pos
			# Check if trail block overlaps with power-up
			if (tx < pu.x + pu.size and tx + BLOCK_SIZE > pu.x and
			    ty < pu.y + pu.size and ty + BLOCK_SIZE > pu.y):
				pu.apply_effect(player1, current_time)
				powerups.remove(pu)
				break

		# Check if still exists (might have been removed by player1)
		if pu not in powerups:
			continue

		# Check if player2's trail crosses this power-up
		for trail_pos in player2.trail:
			tx, ty = trail_pos
			# Check if trail block overlaps with power-up
			if (tx < pu.x + pu.size and tx + BLOCK_SIZE > pu.x and
			    ty < pu.y + pu.size and ty + BLOCK_SIZE > pu.y):
				pu.apply_effect(player2, current_time)
				powerups.remove(pu)
				break

def countdown():
	if theme == "ARES":
		if init.exists():
			pygame.mixer.music.stop()
			pygame.mixer.music.load("music/init.mp3")
			pygame.mixer.music.play(-1)
	elif theme == "LEGACY":
		if clu.exists():
			pygame.mixer.music.stop()
			pygame.mixer.music.load("music/clu.mp3")
			pygame.mixer.music.play(-1)
	elif theme == "82":
		if ring_game_and_escape1.exists():
			pygame.mixer.music.stop()
			pygame.mixer.music.load("music/ring_game_and_escape1.mp3")
			pygame.mixer.music.play(-1)
	for i in range(3, 0, -1):
		WIN.fill(BLACK)
		draw_tron_grid(WIN)
		draw_obstacles()
		draw_powerups()
		draw_sprites()
		draw_scoreboard()
		if theme == "ARES":
			show_message(str(i), "", DARKER_RED)
		elif theme == "LEGACY":
			show_message(str(i))
		elif theme == "82":
			show_message(str(i), "", WHITE)
		pygame.display.update()
		pygame.time.delay(1000)

	# Flash "GO!"
	WIN.fill(BLACK)
	draw_tron_grid(WIN)
	draw_obstacles()
	draw_powerups()
	draw_sprites()
	draw_scoreboard()
	if theme == "ARES":
		show_message("GO!", "", DARKER_RED)
	elif theme == "LEGACY":
		show_message("GO!")
	elif theme == "82":
		show_message("GO!", "", WHITE)
	pygame.display.update()
	pygame.time.delay(800)
	if theme == "ARES":
		game_song = random.choice(game_music_ares)
		selected_song = str(game_song)
		pygame.mixer.music.stop()
		pygame.mixer.music.load(selected_song)
		pygame.mixer.music.play(-1)
	elif theme == "82":
		if ring_game_and_escape2.exists():
			pygame.mixer.music.stop()
			pygame.mixer.music.load("music/ring_game_and_escape2.mp3")
			pygame.mixer.music.play(-1)
	else:
		game_song = random.choice(game_music_legacy)
		selected_song = str(game_song)
		pygame.mixer.music.stop()
		pygame.mixer.music.load(selected_song)
		pygame.mixer.music.play(-1)

def p1_win():
	global game_over, match_over, win_color, win_text, p1_wins
	if theme == "82":
		if derezzed_sound_82_file.exists():
			pygame.mixer.music.stop()
			turn_channel.stop()
			derezz_channel.play(derezzed_sound_82)
	else:
		if derezzed_sound_file.exists():
			pygame.mixer.music.stop()
			derezz_channel.play(derezzed_sound)

	game_over = True

	# --- Draw final collision frame before pausing ---
	WIN.fill(BLACK)
	draw_tron_grid(WIN)
	for point in player1.trail:
		pygame.draw.rect(WIN, BLUE, (*point, BLOCK_SIZE, BLOCK_SIZE))
	for point in player2.trail:
		if theme == "ARES":
			pygame.draw.rect(WIN, RED, (*point, BLOCK_SIZE, BLOCK_SIZE))
		else:
			pygame.draw.rect(WIN, ORANGE, (*point, BLOCK_SIZE, BLOCK_SIZE))
	draw_obstacles()
	draw_powerups()
	draw_sprites()
	draw_scoreboard()
	pygame.display.update()

	# Small pause to show the collision frame
	if theme == "82":
		pygame.time.delay(2600)
	else:
		pygame.time.delay(1800)

	p1_wins += 1
	win_color = BLUE
	# Check for match victory
	if p1_wins >= MAX_SCORE:
		match_over = True
		win_text = "TEAM BLUE WINS THE MATCH!"
		if theme == "ARES":
			if new_directive.exists():
				pygame.mixer.music.load("music/new_directive.mp3")
				pygame.mixer.music.play(-1)
		elif theme == "LEGACY":
			if end_titles.exists():
				pygame.mixer.music.load("music/end_titles.mp3")
				pygame.mixer.music.play(-1)
		elif theme == "82":
			if ending_titles2.exists():
				pygame.mixer.music.load("music/ending_titles2.mp3")
				pygame.mixer.music.play(-1)
	else:
		win_text = "TEAM BLUE WINS!"
		if theme == "ARES":
			if a_question_of_trust.exists():
				pygame.mixer.music.load("music/a_question_of_trust.mp3")
				pygame.mixer.music.play(-1)
		elif theme == "LEGACY":
			if the_grid.exists():
				pygame.mixer.music.load("music/the_grid.mp3")
				pygame.mixer.music.play(-1)
		elif theme == "82":
			if ending_titles1.exists():
				pygame.mixer.music.load("music/ending_titles1.mp3")
				pygame.mixer.music.play(-1)

def p2_win():
	global game_over, match_over, win_color, win_text, p2_wins
	if theme == "82":
		if derezzed_sound_82_file.exists():
			pygame.mixer.music.stop()
			turn_channel.stop()
			derezz_channel.play(derezzed_sound_82)
	else:
		if derezzed_sound_file.exists():
			pygame.mixer.music.stop()
			derezz_channel.play(derezzed_sound)

	game_over = True

	# --- Draw final collision frame before pausing ---
	WIN.fill(BLACK)
	draw_tron_grid(WIN)
	for point in player1.trail:
		pygame.draw.rect(WIN, BLUE, (*point, BLOCK_SIZE, BLOCK_SIZE))
	for point in player2.trail:
		if theme == "ARES":
			pygame.draw.rect(WIN, RED, (*point, BLOCK_SIZE, BLOCK_SIZE))
		else:
			pygame.draw.rect(WIN, ORANGE, (*point, BLOCK_SIZE, BLOCK_SIZE))
	draw_obstacles()
	draw_powerups()
	draw_sprites()
	draw_scoreboard()
	pygame.display.update()

	# Small pause to show the collision frame
	if theme == "82":
		pygame.time.delay(2600)
	else:
		pygame.time.delay(1800)

	p2_wins += 1
	if theme == "ARES":
		win_color = RED
	else:
		win_color = ORANGE
	# Check for match victory
	if p2_wins >= MAX_SCORE:
		match_over = True
		if theme == "ARES":
			win_text = "TEAM RED WINS THE MATCH!"
		else:
			win_text = "TEAM ORANGE WINS THE MATCH!"
		if single_player:
			if theme == "ARES":
				if expendable.exists():
					pygame.mixer.music.load("music/100%_expendable.mp3")
					pygame.mixer.music.play(-1)
			elif theme == "LEGACY":
				if adagio_for_tron.exists():
					pygame.mixer.music.load("music/adagio_for_tron.mp3")
					pygame.mixer.music.play(-1)
			elif theme == "82":
				if sea_of_simulation.exists():
					pygame.mixer.music.load("music/sea_of_simulation.mp3")
					pygame.mixer.music.play(-1)
		else:
			if theme == "ARES":
				if new_directive.exists():
					pygame.mixer.music.load("music/new_directive.mp3")
					pygame.mixer.music.play(-1)
			elif theme == "LEGACY":
				if end_titles.exists():
					pygame.mixer.music.load("music/end_titles.mp3")
					pygame.mixer.music.play(-1)
			elif theme == "82":
				if ending_titles2.exists():
					pygame.mixer.music.load("music/ending_titles2.mp3")
					pygame.mixer.music.play(-1)
	else:
		if theme == "ARES":
			win_text = "TEAM RED WINS!"
		else:
			win_text = "TEAM ORANGE WINS!"
		if single_player:
			if theme == "ARES":
				if in_the_image_of.exists():
					pygame.mixer.music.load("music/in_the_image_of.mp3")
					pygame.mixer.music.play(-1)
			elif theme == "LEGACY":
				if rinzler.exists():
					pygame.mixer.music.load("music/rinzler.mp3")
					pygame.mixer.music.play(-1)
			elif theme == "82":
				if weve_got_company.exists():
					pygame.mixer.music.load("music/weve_got_company.mp3")
					pygame.mixer.music.play(-1)
		else:
			if theme == "ARES":
				if a_question_of_trust.exists():
					pygame.mixer.music.load("music/a_question_of_trust.mp3")
					pygame.mixer.music.play(-1)
			elif theme == "LEGACY":
				if the_grid.exists():
					pygame.mixer.music.load("music/the_grid.mp3")
					pygame.mixer.music.play(-1)
			elif theme == "82":
				if ending_titles1.exists():
					pygame.mixer.music.load("music/ending_titles1.mp3")
					pygame.mixer.music.play(-1)

def ai_control(current_game_time):
	"""AI for p2 bike that avoids collisions and seeks power-ups."""
	# Check turn cooldown
	if not player2.can_turn(current_game_time, turn_cooldown):
		return

	possible_dirs = [dirs["UP"], dirs["DOWN"], dirs["LEFT"], dirs["RIGHT"]]

	def will_collide(pos, dir_vec, steps=12):
		"""Predict if moving forward will cause a collision using simplified hitbox detection."""
		# Get sprite dimensions based on theme
		if theme == "LEGACY" or theme == "ARES":
			sprite_w = legacy_width
			sprite_h = legacy_height
		elif theme == "82":
			sprite_w = width_82
			sprite_h = height_82

		back_margin = 4
		# Calculate rotation angle for the test direction
		mag = math.hypot(dir_vec[0], dir_vec[1])
		if mag == 0:
			return True

		# Use a simplified rectangular hitbox check instead of full rotated rectangle
		# This is much faster and still reasonably accurate for AI purposes
		front_length = sprite_w - back_margin
		nx_norm, ny_norm = dir_vec[0] / mag, dir_vec[1] / mag

		# Define a safety margin around the bike
		# Reduced from 0.5 to 0.15 to allow AI to navigate tighter spaces
		# The actual hitbox is 90% of sprite size, so this gives minimal buffer
		safety_margin = sprite_w * 0.15

		# Look ahead specified steps with larger step size for performance
		step_increment = max(1, SPEED)  # Check every SPEED pixels instead of every pixel
		for i in range(step_increment, steps * SPEED + 1, step_increment):
			# Calculate test position
			test_pos_x = pos[0] + nx_norm * i
			test_pos_y = pos[1] + ny_norm * i

			# Check wall collisions with margin
			fx = test_pos_x + nx_norm * front_length
			fy = test_pos_y + ny_norm * front_length
			if fx < safety_margin or fx >= WIDTH - safety_margin or fy < safety_margin or fy >= HEIGHT - safety_margin:
				return True

			# Check trail collisions using a simple radius check (much faster)
			TRAIL_SAFETY_MARGIN = 50
			test_point = (int(test_pos_x), int(test_pos_y))

			# Quick check: is the test point near any trail?
			for trail_pos in player1.trail:
				distance = abs(test_pos_x - trail_pos[0]) + abs(test_pos_y - trail_pos[1])  # Manhattan distance
				if distance < safety_margin:
					return True

			# Check own trail with safety margin
			own_trail_to_check = player2.trail[:-TRAIL_SAFETY_MARGIN] if len(player2.trail) > TRAIL_SAFETY_MARGIN else []
			for trail_pos in own_trail_to_check:
				distance = abs(test_pos_x - trail_pos[0]) + abs(test_pos_y - trail_pos[1])
				if distance < safety_margin:
					return True

			# Check obstacle collisions with margin
			for obs in obstacles:
				# Simple AABB check with margin
				if (test_pos_x - safety_margin < obs.x + obs.size and
					test_pos_x + safety_margin > obs.x and
					test_pos_y - safety_margin < obs.y + obs.size and
					test_pos_y + safety_margin > obs.y):
					return True

		return False

	def get_direction_to_powerup(bike_pos, powerup):
		"""Calculate which direction moves toward a power-up."""
		bx, by = bike_pos
		px, py = powerup.x + powerup.size // 2, powerup.y + powerup.size // 2

		dx = px - bx
		dy = py - by

		# Determine primary and secondary directions
		directions = []
		if abs(dx) > abs(dy):
			# Horizontal movement is more important
			if dx > 0:
				directions.append(dirs["RIGHT"])
			else:
				directions.append(dirs["LEFT"])
			if dy > 0:
				directions.append(dirs["DOWN"])
			elif dy < 0:
				directions.append(dirs["UP"])
		else:
			# Vertical movement is more important
			if dy > 0:
				directions.append(dirs["DOWN"])
			else:
				directions.append(dirs["UP"])
			if dx > 0:
				directions.append(dirs["RIGHT"])
			elif dx < 0:
				directions.append(dirs["LEFT"])

		return directions

	def is_powerup_reachable(bike_pos, powerup):
		"""Check if power-up is reachable by testing if we can get closer to it."""
		target_dirs = get_direction_to_powerup(bike_pos, powerup)

		# Check if ANY of the directions toward the power-up are safe
		for target_dir in target_dirs:
			# Don't turn 180 degrees from current direction
			if (player2.dir == dirs["UP"] and target_dir == dirs["DOWN"]) or \
			   (player2.dir == dirs["DOWN"] and target_dir == dirs["UP"]) or \
			   (player2.dir == dirs["LEFT"] and target_dir == dirs["RIGHT"]) or \
			   (player2.dir == dirs["RIGHT"] and target_dir == dirs["LEFT"]):
				continue

			# If this direction is safe, power-up is potentially reachable
			if not will_collide(bike_pos, target_dir, steps=15):
				return True

		# No safe route found toward the power-up
		return False

	# Find nearest power-up
	nearest_powerup = None
	min_distance = float('inf')
	if powerups:
		for powerup in powerups:
			px, py = powerup.x + powerup.size // 2, powerup.y + powerup.size // 2
			distance = math.hypot(px - player2.pos[0], py - player2.pos[1])
			if distance < min_distance:
				min_distance = distance
				nearest_powerup = powerup

	# Try to move toward power-up if one exists, is reasonably close, AND is reachable
	if nearest_powerup and min_distance < 300 and is_powerup_reachable(player2.pos, nearest_powerup):
		target_dirs = get_direction_to_powerup(player2.pos, nearest_powerup)

		# Check if we can safely move toward the power-up
		for target_dir in target_dirs:
			# Don't turn 180 degrees
			if (player2.dir == dirs["UP"] and target_dir == dirs["DOWN"]) or \
			   (player2.dir == dirs["DOWN"] and target_dir == dirs["UP"]) or \
			   (player2.dir == dirs["LEFT"] and target_dir == dirs["RIGHT"]) or \
			   (player2.dir == dirs["RIGHT"] and target_dir == dirs["LEFT"]):
				continue

			# Check if this direction is safe
			if not will_collide(player2.pos, target_dir, steps=15):
				player2.dir = target_dir
				player2.last_turn_time = current_game_time
				return

	# If current direction is safe, keep going
	if not will_collide(player2.pos, player2.dir):
		return

	# Otherwise, pick the safest turn (evaluate all safe directions)
	def evaluate_direction_safety(direction, max_steps=50):
		"""Calculate how many steps the AI can safely move in a direction."""
		# Use the will_collide function to test different lookahead distances
		# Binary search to find the maximum safe distance
		low, high = 0, max_steps
		safe_steps = 0

		while low <= high:
			mid = (low + high) // 2
			if not will_collide(player2.pos, direction, steps=mid):
				safe_steps = mid
				low = mid + 1
			else:
				high = mid - 1

		return safe_steps

	safe_dirs = [d for d in possible_dirs if not will_collide(player2.pos, d)]

	# Filter out 180-degree turns
	safe_dirs = [d for d in safe_dirs if not (
		(player2.dir == dirs["UP"] and d == dirs["DOWN"]) or
		(player2.dir == dirs["DOWN"] and d == dirs["UP"]) or
		(player2.dir == dirs["LEFT"] and d == dirs["RIGHT"]) or
		(player2.dir == dirs["RIGHT"] and d == dirs["LEFT"])
	)]

	if safe_dirs:
		# Evaluate safety of each direction and pick the safest
		best_dir = None
		best_safety = -1

		for direction in safe_dirs:
			safety = evaluate_direction_safety(direction)
			if safety > best_safety:
				best_safety = safety
				best_dir = direction

		if best_dir:
			player2.dir = best_dir
			player2.last_turn_time = current_game_time

def step_move_player(bike, other_bike, effective_speed, sprite_width, sprite_height, back_margin=4):
	"""Move a bike and check for collisions using rotated rectangle collision detection."""
	if effective_speed <= 0:
		return False

	# Normalize direction vector
	mag = math.hypot(bike.dir[0], bike.dir[1])
	if mag == 0:
		return False
	nx, ny = bike.dir[0] / mag, bike.dir[1] / mag

	# front offset from back
	front_length = sprite_width - back_margin

	# Calculate rotation angle
	rad = math.atan2(-bike.dir[1], bike.dir[0])
	angle_deg = math.degrees(rad)

	# Use 90% of sprite dimensions for tight hitbox
	tight_width = sprite_width * 0.9
	tight_height = sprite_height * 0.9

	# Skip the last few trail blocks to avoid self-collision with recent trail
	# At SPEED=5 and 60 FPS, the bike moves 5 pixels per frame
	# The bike sprite is ~20-40 pixels long, so we need to skip enough blocks
	# to clear the bike's entire length plus turning radius
	TRAIL_SAFETY_MARGIN = 50  # Number of recent trail blocks to skip for own trail

	# Helper function to check if a position would cause collision
	def would_collide(test_x, test_y):
		"""Check if moving to position (test_x, test_y) would cause a collision."""
		# Check wall collisions (using front position)
		fx = test_x + nx * front_length
		fy = test_y + ny * front_length
		if fx < 0 or fx >= WIDTH or fy < 0 or fy >= HEIGHT:
			return True

		# Calculate front hitbox position
		# The front hitbox is a small rectangle at the tip of the bike
		# positioned at 85% of the bike's length from the back
		front_offset = sprite_width * 0.85
		front_center_x = test_x + 2 + nx * front_offset
		front_center_y = test_y + 2 + ny * front_offset

		# Front hitbox dimensions - small rectangle at the tip
		# Width is 15% of bike length, height is full bike width
		front_hitbox_width = sprite_width * 0.25
		front_hitbox_height = tight_height

		# Also calculate body hitbox for turn collision detection
		# The body extends from the back position
		back_margin = 4
		body_center_offset = sprite_width / 2 - back_margin
		body_center_x = test_x + 2 + nx * body_center_offset
		body_center_y = test_y + 2 + ny * body_center_offset
		body_width = sprite_width * 0.9
		body_height = tight_height

		# Create a broad-phase AABB for the front of the bike to quickly reject distant objects
		# This optimization dramatically improves performance with long trails
		front_aabb = pygame.Rect(0, 0, front_hitbox_width + 20, front_hitbox_height + 20)
		front_aabb.center = (front_center_x, front_center_y)

		# Also create a broad-phase AABB for the body
		body_aabb_broad = pygame.Rect(0, 0, body_width + 20, body_height + 20)
		body_aabb_broad.center = (body_center_x, body_center_y)

		# Check other bike's trail (all positions)
		# No inflation - hitboxes must actually touch
		for trail_pos in other_bike.trail:
			trail_rect = pygame.Rect(trail_pos[0], trail_pos[1], BLOCK_SIZE, BLOCK_SIZE)
			# Quick AABB rejection test - skip expensive rotated rect check if not close
			# Check both front and body AABBs
			if front_aabb.colliderect(trail_rect):
				# Check if front hitbox intersects trail
				if rotated_rect_intersects_rect(front_center_x, front_center_y, front_hitbox_width, front_hitbox_height, angle_deg, trail_rect):
					return True
			if body_aabb_broad.colliderect(trail_rect):
				# Also check if body hitbox intersects trail (important for turns)
				if rotated_rect_intersects_rect(body_center_x, body_center_y, body_width, body_height, angle_deg, trail_rect):
					return True

		# Check own trail (skip recent positions to avoid false collisions)
		own_trail_to_check = bike.trail[:-TRAIL_SAFETY_MARGIN] if len(bike.trail) > TRAIL_SAFETY_MARGIN else []
		for trail_pos in own_trail_to_check:
			trail_rect = pygame.Rect(trail_pos[0], trail_pos[1], BLOCK_SIZE, BLOCK_SIZE)
			# Quick AABB rejection test - skip expensive rotated rect check if not close
			# Check both front and body AABBs
			if front_aabb.colliderect(trail_rect):
				# Check if front hitbox intersects trail
				if rotated_rect_intersects_rect(front_center_x, front_center_y, front_hitbox_width, front_hitbox_height, angle_deg, trail_rect):
					return True
			if body_aabb_broad.colliderect(trail_rect):
				# Also check if body hitbox intersects trail (important for turns)
				if rotated_rect_intersects_rect(body_center_x, body_center_y, body_width, body_height, angle_deg, trail_rect):
					return True

		# Check obstacle collisions
		for obs in obstacles:
			obs_rect = pygame.Rect(obs.x, obs.y, obs.size, obs.size)
			# Quick AABB rejection test - skip expensive rotated rect check if not close
			if not front_aabb.colliderect(obs_rect):
				continue
			# Check if front hitbox intersects obstacle
			if rotated_rect_intersects_rect(front_center_x, front_center_y, front_hitbox_width, front_hitbox_height, angle_deg, obs_rect):
				return True

		return False

	# Move step-by-step, checking BEFORE each move
	steps = max(1, int(effective_speed))
	step_size = effective_speed / steps
	distance_moved = 0.0

	for step in range(steps):
		# Calculate the next position
		next_x = bike.pos[0] + nx * step_size
		next_y = bike.pos[1] + ny * step_size

		# Check if moving to this position would cause collision
		if would_collide(next_x, next_y):
			# Collision detected - stop here and trigger game over
			if bike == player1:
				p2_win()
			else:
				p1_win()
			return True

		# Safe to move - update position
		bike.pos[0] = next_x
		bike.pos[1] = next_y
		distance_moved += step_size

	# Add trail points for rendering and collision detection
	new_pos = (int(bike.pos[0]), int(bike.pos[1]))
	bike.add_trail_point(new_pos)

	return False

def run_game():
	"""Main game loop."""
	global game_over, win_text, win_color, game_time_offset, last_powerup_spawn

	# --- Start Screen ---
	WIN.blit(background, (0, 0))
	main_menu()
	running = True
	game_over = False
	while running:
		if not game_over:
			clock.tick(60)

			for event in pygame.event.get():
				if event.type == pygame.QUIT:
					pygame.quit()
					sys.exit()

			keys = pygame.key.get_pressed()

			current_time = pygame.time.get_ticks() - game_time_offset

			if current_time - last_powerup_spawn > POWERUP_SPAWN_INTERVAL:
				spawn_powerup()
				last_powerup_spawn = current_time

			# Player 1 (WASD) â Disable turning if frozen
			if not player1.is_frozen(current_time):
				if player1.can_turn(current_time, turn_cooldown):
					if keys[pygame.K_w] and player1.dir != dirs["DOWN"] and player1.dir != dirs["UP"]:
						if theme == "82":
							if turn_sound_82_file.exists():
								turn_channel.stop()
								turn_channel.play(turn_sound_82)
						player1.dir = dirs["UP"]
						player1.last_turn_time = current_time
					elif keys[pygame.K_s] and player1.dir != dirs["UP"] and player1.dir != dirs["DOWN"]:
						if theme == "82":
							if turn_sound_82_file.exists():
								turn_channel.stop()
								turn_channel.play(turn_sound_82)
						player1.dir = dirs["DOWN"]
						player1.last_turn_time = current_time
					elif keys[pygame.K_a] and player1.dir != dirs["RIGHT"] and player1.dir != dirs["LEFT"]:
						if theme == "82":
							if turn_sound_82_file.exists():
								turn_channel.stop()
								turn_channel.play(turn_sound_82)
						player1.dir = dirs["LEFT"]
						player1.last_turn_time = current_time
					elif keys[pygame.K_d] and player1.dir != dirs["LEFT"] and player1.dir != dirs["RIGHT"]:
						if theme == "82":
							if turn_sound_82_file.exists():
								turn_channel.stop()
								turn_channel.play(turn_sound_82)
						player1.dir = dirs["RIGHT"]
						player1.last_turn_time = current_time

			# Player 2 (Arrows or AI) â Disable turning if frozen
			if not player2.is_frozen(current_time):
				if single_player:
					ai_control(current_time)
					# if theme == "82":
					# 	if turn_sound_82_file.exists():
					# 		turn_sound_82.play()
				else:
					if player2.can_turn(current_time, turn_cooldown):
						if keys[pygame.K_UP] and player2.dir != dirs["DOWN"] and player2.dir != dirs["UP"]:
							player2.dir = dirs["UP"]
							player2.last_turn_time = current_time
							if theme == "82":
								if turn_sound_82_file.exists():
									turn_channel.stop()
									turn_channel.play(turn_sound_82)
						elif keys[pygame.K_DOWN] and player2.dir != dirs["UP"] and player2.dir != dirs["DOWN"]:
							player2.dir = dirs["DOWN"]
							player2.last_turn_time = current_time
							if theme == "82":
								if turn_sound_82_file.exists():
									turn_channel.stop()
									turn_channel.play(turn_sound_82)
						elif keys[pygame.K_LEFT] and player2.dir != dirs["RIGHT"] and player2.dir != dirs["LEFT"]:
							player2.dir = dirs["LEFT"]
							player2.last_turn_time = current_time
							if theme == "82":
								if turn_sound_82_file.exists():
									turn_channel.stop()
									turn_channel.play(turn_sound_82)
						elif keys[pygame.K_RIGHT] and player2.dir != dirs["LEFT"] and player2.dir != dirs["RIGHT"]:
							player2.dir = dirs["RIGHT"]
							player2.last_turn_time = current_time
							if theme == "82":
								if turn_sound_82_file.exists():
									turn_channel.stop()
									turn_channel.play(turn_sound_82)

			# Get effective speeds considering status effects
			effective_speed_p1 = player1.get_effective_speed(SPEED, current_time)
			effective_speed_p2 = player2.get_effective_speed(SPEED, current_time)

			# Get sprite dimensions based on theme
			if theme == "LEGACY" or theme == "ARES":
				sprite_w = legacy_width
				sprite_h = legacy_height
			elif theme == "82":
				sprite_w = width_82
				sprite_h = height_82

			# Move both bikes
			collided1 = step_move_player(player1, player2, effective_speed_p1, sprite_w, sprite_h, back_margin=4)
			if not collided1:
				# Move player 2 (only if game not already ended)
				collided2 = step_move_player(player2, player1, effective_speed_p2, sprite_w, sprite_h, back_margin=4)

			p1_front = player1.get_front_pos(sprite_w)
			p2_front = player2.get_front_pos(sprite_w)

			# Check bike-to-bike collision - front hitbox vs full body
			# Rule: If the front of a bike touches any part of another bike, the bike whose front is touching loses
			dx1, dy1 = player1.dir
			mag1 = math.hypot(dx1, dy1)
			dx2, dy2 = player2.dir
			mag2 = math.hypot(dx2, dy2)

			bikes_collided = False
			collision_winner = None  # Will be set to player who wins, or None for draw

			if mag1 > 0 and mag2 > 0:  # Both bikes are moving
				# Normalize direction vectors
				nx1, ny1 = dx1 / mag1, dy1 / mag1
				nx2, ny2 = dx2 / mag2, dy2 / mag2

				# Calculate rotation angles
				rad1 = math.atan2(-dy1, dx1)
				angle1_deg = math.degrees(rad1)
				rad2 = math.atan2(-dy2, dx2)
				angle2_deg = math.degrees(rad2)

				# Calculate full body hitbox centers for both bikes
				back_margin = 4
				back_center_x1 = player1.pos[0] + 2
				back_center_y1 = player1.pos[1] + 2
				back_center_x2 = player2.pos[0] + 2
				back_center_y2 = player2.pos[1] + 2

				local_center1 = pygame.math.Vector2((sprite_w/2 - back_margin, 0))
				rotated_center1 = local_center1.rotate(-angle1_deg)
				center_x1 = back_center_x1 + rotated_center1.x
				center_y1 = back_center_y1 + rotated_center1.y

				local_center2 = pygame.math.Vector2((sprite_w/2 - back_margin, 0))
				rotated_center2 = local_center2.rotate(-angle2_deg)
				center_x2 = back_center_x2 + rotated_center2.x
				center_y2 = back_center_y2 + rotated_center2.y

				# Full body hitboxes (90% of sprite size)
				full_body_width = sprite_w * 0.9
				full_body_height = sprite_h * 0.9

				# Calculate front hitbox positions (at 85% of bike length)
				front_offset = sprite_w * 0.85
				front1_x = player1.pos[0] + 2 + nx1 * front_offset
				front1_y = player1.pos[1] + 2 + ny1 * front_offset
				front2_x = player2.pos[0] + 2 + nx2 * front_offset
				front2_y = player2.pos[1] + 2 + ny2 * front_offset

				# Front hitbox dimensions - small rectangle at the tip
				front_hitbox_width = sprite_w * 0.25
				front_hitbox_height = sprite_h * 0.9

				# Create AABBs for full bodies
				p1_body_aabb = pygame.Rect(0, 0, full_body_width, full_body_height)
				p1_body_aabb.center = (center_x1, center_y1)
				p2_body_aabb = pygame.Rect(0, 0, full_body_width, full_body_height)
				p2_body_aabb.center = (center_x2, center_y2)

				# Check if player1's front touches player2's body
				p1_front_hits_p2 = rotated_rect_intersects_rect(front1_x, front1_y, front_hitbox_width, front_hitbox_height, angle1_deg, p2_body_aabb)

				# Check if player2's front touches player1's body
				p2_front_hits_p1 = rotated_rect_intersects_rect(front2_x, front2_y, front_hitbox_width, front_hitbox_height, angle2_deg, p1_body_aabb)

				if p1_front_hits_p2 and p2_front_hits_p1:
					# Both fronts hit - head-on collision, it's a draw
					bikes_collided = True
					collision_winner = None
				elif p1_front_hits_p2:
					# Player1's front hit player2's body - player1 loses
					bikes_collided = True
					collision_winner = player2
				elif p2_front_hits_p1:
					# Player2's front hit player1's body - player2 loses
					bikes_collided = True
					collision_winner = player1

			if bikes_collided:
				# Determine outcome based on who won
				if collision_winner is None:
					# Head-on collision - draw
					# Play collision sound for draw
					if theme == "82":
						if derezzed_sound_82_file.exists():
							pygame.mixer.music.stop()
							turn_channel.stop()
							derezz_channel.play(derezzed_sound_82)
					else:
						if derezzed_sound_file.exists():
							pygame.mixer.music.stop()
							derezz_channel.play(derezzed_sound)

					game_over = True

					# --- Draw final collision frame before pausing ---
					WIN.fill(BLACK)
					draw_tron_grid(WIN)
					for point in player1.trail:
						pygame.draw.rect(WIN, BLUE, (*point, BLOCK_SIZE, BLOCK_SIZE))
					for point in player2.trail:
						if theme == "ARES":
							pygame.draw.rect(WIN, RED, (*point, BLOCK_SIZE, BLOCK_SIZE))
						else:
							pygame.draw.rect(WIN, ORANGE, (*point, BLOCK_SIZE, BLOCK_SIZE))
					draw_obstacles()
					draw_powerups()
					draw_sprites()
					draw_scoreboard()
					pygame.display.update()

					# Small pause to show the collision frame
					if theme == "82":
						pygame.time.delay(2600)
					else:
						pygame.time.delay(1800)

					win_text = "DRAW!"
					if theme == "ARES":
						win_color = DARKER_RED
						if this_changes_everything.exists():
							pygame.mixer.music.load("music/this_changes_everything.mp3")
							pygame.mixer.music.play(-1)
					elif theme == "LEGACY":
						win_color = TEAL
						if arena.exists():
							pygame.mixer.music.load("music/arena.mp3")
							pygame.mixer.music.play(-1)
					else:
						win_color = WHITE
						if arena.exists():
							pygame.mixer.music.load("music/arena.mp3")
							pygame.mixer.music.play(-1)
				elif collision_winner == player2:
					# Player1's front hit player2 - player2 wins
					# p2_win() will handle sound, drawing, and music
					p2_win()
				elif collision_winner == player1:
					# Player2's front hit player1 - player1 wins
					# p1_win() will handle sound, drawing, and music
					p1_win()

			# --- Power-up collisions ---
			check_powerup_collision(p1_front, player1, current_time)
			check_powerup_collision(p2_front, player2, current_time)
			check_trail_powerup_collisions(current_time)

			# Render everything
			WIN.fill(BLACK)
			draw_tron_grid(WIN)
			for point in player1.trail:
				pygame.draw.rect(WIN, BLUE, (*point, BLOCK_SIZE, BLOCK_SIZE))
			for point in player2.trail:
				if theme == "ARES":
					pygame.draw.rect(WIN, RED, (*point, BLOCK_SIZE, BLOCK_SIZE))
				else:
					pygame.draw.rect(WIN, ORANGE, (*point, BLOCK_SIZE, BLOCK_SIZE))
			draw_obstacles()
			draw_powerups()
			draw_sprites()
			draw_scoreboard()
			pygame.display.update()

		else:
			# --- GAME OVER STATE ---
			if match_over:
				WIN.fill(BLACK)
				draw_tron_grid(WIN)
				for point in player1.trail:
					pygame.draw.rect(WIN, BLUE, (*point, BLOCK_SIZE, BLOCK_SIZE))
				for point in player2.trail:
					if theme == "ARES":
						pygame.draw.rect(WIN, RED, (*point, BLOCK_SIZE, BLOCK_SIZE))
					else:
						pygame.draw.rect(WIN, ORANGE, (*point, BLOCK_SIZE, BLOCK_SIZE))
				draw_obstacles()
				draw_powerups()
				draw_sprites()
				draw_scoreboard()
				show_message(win_text, "Press ESC to quit", win_color)
				pygame.display.update()

				for event in pygame.event.get():
					if event.type == pygame.QUIT:
						running = False
					elif event.type == pygame.KEYDOWN:
						if event.key == pygame.K_ESCAPE:
							main_menu()

			else:
				WIN.fill(BLACK)
				draw_tron_grid(WIN)
				for point in player1.trail:
					pygame.draw.rect(WIN, BLUE, (*point, BLOCK_SIZE, BLOCK_SIZE))
				for point in player2.trail:
					if theme == "ARES":
						pygame.draw.rect(WIN, RED, (*point, BLOCK_SIZE, BLOCK_SIZE))
					else:
						pygame.draw.rect(WIN, ORANGE, (*point, BLOCK_SIZE, BLOCK_SIZE))
				draw_obstacles()
				draw_powerups()
				draw_sprites()
				draw_scoreboard()
				show_message(win_text, "Press SPACE to continue", win_color)
				pygame.display.update()

				for event in pygame.event.get():
					if event.type == pygame.QUIT:
						running = False
					elif event.type == pygame.KEYDOWN:
						if event.key == pygame.K_SPACE:
							reset_game()
						elif event.key == pygame.K_ESCAPE:
							main_menu()

	pygame.quit()